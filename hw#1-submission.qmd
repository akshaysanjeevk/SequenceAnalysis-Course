---
title: "Sequance Analysis Assignment#1"
format:
  html:
    code-fold: true
jupyter: python3
---

# Greedy Motif Search 

Functions written are listed below.
- Bulding the position weight matrix: 
```python
from Bio import SeqIO
import numpy as np
import math

def totalcount(x, pseudocount):
    alpha = ['A', 'T', 'G', 'C']
    counts = np.array([np.sum(x==nt) for nt in alpha])
    finalcount = (counts + pseudocount)/(len(x) + 4*pseudocount)
    return finalcount

def profile(DNA, k, pos, log_odd=True):
    N = len(DNA)# or pos0
    x = np.empty((N, k), dtype=str) #matrix with k-mers
    W = np.empty((4, k)) #position weight matrix
    for i in range(N):
        x[i, :] = list(DNA[i][pos[i]:pos[i]+k])
    for j in range(k):
        W[:,j] = totalcount(x[:,j], pseudocount=1)
    if log_odd==True: # log-odds matrix
        W2 = np.log(W*4)/np.log(4)
    else: 
        W2 = W
    return W2
```
- Computing the log-likelihood ratio of a given sequence `s`. 
```python
def llr(profile, s):
    ref = {
        'A':0,
        'T':1,
        'G':2,
        'C':3
    }
    llratio = 0
    for i in range(len(s)):
        llratio += profile[ref[s[i]], i]
    return llratio
```
- Finding most probable positions in a set of given sequences `DNA`, based on a postion weight matrix `profile`:
```python
def motifpos(profile, DNA):
    N = len(DNA)
    k = profile.shape[1]
    pos = np.empty(N, dtype=int)
    for i in range(N):
        maxllr = -math.inf
        for j in range(len(DNA[i])-k+1):
            llrval = llr(profile, DNA[i][j:j+k])
            if llrval > maxllr:
                maxllr = llrval
                pos[i] = j
    return pos  
```
- This function brings together all the above written functions and executes a greedy search for motifs in the given sequences, `DNA` for `k`-mer in it.
def GreedySearch(DNA, k):
```python
    N = len(DNA)
    pos = np.array([np.random.randint(0, len(DNA[i]) - k) for i in range(N)])
    while True:
        old_pos = pos.copy()
        pwm = profile(DNA, k, pos)
        pos = motifpos(pwm, DNA)
        if np.array_equal(old_pos, pos):
            break
    return pos
```
Loding data and computing k-mers from the given datasets:
1. `synth_50_strong.fa`
```python
strong = [str(record.seq) for record in SeqIO.parse("synth_50_strong.fa", "fasta")]

k=15
strong_pos = GreedySearch(strong, k)
print(f"{k}-mers for 'synth_50_strong.fa':")
for i in range(len(strong)):
    print(strong[i][strong_pos[i]:strong_pos[i]+k])
```
1. `synth_50_weak.fa`
```python
weak = [str(record.seq) for record in SeqIO.parse("synth_50_weak.fa", "fasta")]
weak_pos = GreedySearch(weak, k)
print(f"{k}-mers for 'synth_50_weak.fa':") 
for i in range(len(weak)):
    print(weak[i][weak_pos[i]:weak_pos[i]+k])
```


